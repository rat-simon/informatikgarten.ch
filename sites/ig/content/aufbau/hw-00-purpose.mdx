---
title: ðŸ—ï¸ Was erschaffen wir?
---
> [!success] Lernziele
> 
> - Sie kÃ¶nnen den Unterschied zwischen **Abstraktion** und **Implementierung** eines Moduls beschreiben.

In diesem Modul bauen wir zusammen **einen rudimentÃ¤ren Rechner, der zwei Zahlen addieren kann**. Dazu erhalten Sie ein kleines Logikboard mit Batterie und Kabel. 

![[logicboard-perspective.jpg]]

## Divide and conquer mit Modulen! 

> [!idea] Wie baut man einen Computer von Grund auf?
> 
> "Sie fragen sich vielleicht, wie es mÃ¶glich ist, ein komplettes Computersystem von Grund auf zu konstruieren, das mit nichts anderem als elementarsten Schaltkreisen beginnt. Das muss ein gigantisches Unterfangen sein! Wir gehen mit dieser KomplexitÃ¤t um, indem wir **das System in Module aufteilen**. Jedes Modul wird ... separat in einem eigenstÃ¤ndigen Projekt aufgebaut. Sie werden sich vielleicht fragen, wie es mÃ¶glich ist, diese Module isoliert zu beschreiben und zu bauen? Sie sind doch sicher miteinander verbunden! Wie wir ... zeigen werden, impliziert ein gutes modulares Design genau das: **Sie kÃ¶nnen an den einzelnen Modulen unabhÃ¤ngig voneinander arbeiten, wÃ¤hrend Sie den Rest des Systems vÃ¶llig ignorieren**. Wenn das System gut konzipiert ist, kÃ¶nnen Sie diese Module in beliebiger Reihenfolge und sogar parallel zueinander aufbauen, wenn Sie im Team arbeiten.
> 
> Die kognitive FÃ¤higkeit des "Divide & Conquer", also ein komplexes System in Ã¼berschaubare Module aufzuteilen, wird durch einen weiteren kognitiven Kniff gestÃ¤rkt: unsere **FÃ¤higkeit, zwischen der Abstraktion und der Implementierung der einzelnen Module zu unterscheiden**. In der Informatik nehmen wir diese Worte konkret: Die **Abstraktion** beschreibt, **was** das Modul tut, und die **Implementierung** beschreibt, **wie** es dies tut. Mit dieser Unterscheidung im Hinterkopf lautet die wichtigste Regel in der Systemtechnik: Wenn Sie ein Modul als Baustein verwenden - egal welches Modul -, sollten Sie sich ausschliesslich auf die Abstraktion des Moduls konzentrieren und die Implementierungsdetails vÃ¶llig ignorieren."
> 
> *Nisan, N. & Schocken, S. (2005) The Elements of Computing Systems: Building a Modern Computer from First Principles*

Zusammengefasst:
- Das grosse Ganze wird in einzelne **Module** aufgeteilt.
- Bei Modulen unterscheiden wir ihre **Abstraktion** (inkl. der Schnittstelle) von ihrer **Implementierung** unterscheiden.

![[module-single-interface-abstraction.excalidraw]]
Ein einfaches Beispiel: Betrachten wir Microsoft **Word** als Modul.
- Sie nutzen eine **Abstraktion** von Word, nÃ¤mlich die grafische OberflÃ¤che. Mit dieser Schnittstelle kÃ¶nnen Sie das Programm bedienen. Aber wissen Sie, wie Word funktioniert? Nein! Sie haben keine Ahnung - und ich auch nicht.
- Die **Implementierung** ist der Programmier-Quellcode von Word. Doch dieser wird von Microsoft nicht publiziert und als geistiges Eigentum beschÃ¼tzt. Das heisst: Wir kÃ¶nnen gar nicht wissen, wie Word genau funktioniert.

In der Welt der Informatik werden Schnittstellen oft standardisiert und vorgeschrieben - z.B. Stecker, Kommunikationsprotokolle, APIs (Programmier-Schnittstellen), die Parameter einer Funktion, etc. Aber wie diese Schnittstellen von jedem Computer implementiert werden, ist freigestellt, weil es letztlich unÃ¼berprÃ¼fbar ist.

> [!hint] Tipp
> 
> Mit diesen Konzepten kÃ¶nnen Sie die KomplexitÃ¤t im Kopf reduzieren. Fragen Sie sich: 
> - Welches Modul schaue ich gerade an? Ignorieren Sie den ganzen Rest fÃ¼r den Moment einfach!
> - Muss ich die Implementierung des Moduls verstehen? Falls nicht, nutzen Sie einfach die Schnittstelle!
